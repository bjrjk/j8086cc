package com.renjikai.j8086cc.intermediate;

import java.util.ArrayList;
import java.util.HashMap;

import org.antlr.v4.runtime.tree.ParseTreeProperty;

import com.renjikai.j8086cc.antlr.j8086ccBaseVisitor;
import com.renjikai.j8086cc.antlr.j8086ccParser;
import com.renjikai.j8086cc.utils.Logger;

public class SyntaxTreeVisitor extends j8086ccBaseVisitor<String> {

	public final static String poweredBy = "// j8086cInter Language, Generated by j8086cc, Jack Ren\n";
	Counter lblCnter = new Counter();
	Counter tmpVarCnter = new Counter();
	ParseTreeProperty<Integer> CtlBeforeLabel = new ParseTreeProperty<Integer>();
	ParseTreeProperty<Integer> CtlAfterLabel = new ParseTreeProperty<Integer>();
	ParseTreeProperty<Symbol> exprSymbol = new ParseTreeProperty<Symbol>();
	ParseTreeProperty<SymbolTable> symbolTableTree = new ParseTreeProperty<SymbolTable>();
	HashMap<String, Symbol> globalSymbolTable = new HashMap<String, Symbol>();
	FunctionTable functionTable = new FunctionTable();

	public String genArrayShiftSize(Symbol s, j8086ccParser.LeftValueContext ctx) {
		String result = "";
		Symbol sum = SyntaxTreeHelper.genIntLiteralNode(tmpVarCnter);
		result += String.format(InterDefines.MOVI, sum.toString(), 0) + "\n";
		for (int i = 0; i < ctx.expr().size(); i++) {
			result += visit(ctx.expr(i));
			Symbol subS = exprSymbol.get(ctx.expr(i));
			Symbol mult = SyntaxTreeHelper.genIntLiteralNode(tmpVarCnter);
			result += String.format(InterDefines.MOVI, mult.toString(), s.getDimensionSize(i)) + "\n";
			result += String.format(InterDefines.MUL, mult.toString(), mult.toString(), subS.toString()) + "\n";
			result += String.format(InterDefines.ADD, sum.toString(), sum.toString(), mult.toString()) + "\n";
		}
		Symbol dataSize = SyntaxTreeHelper.genIntLiteralNode(tmpVarCnter);
		result += String.format(InterDefines.MOVI, dataSize.toString(), s.dataSize) + "\n";
		result += String.format(InterDefines.MUL, sum.toString(), sum.toString(), dataSize.toString()) + "\n";
		exprSymbol.put(ctx, sum);
		return result;
	}

	@Override

	public String visitProgram(j8086ccParser.ProgramContext ctx) {
		SymbolTable tmpSymbolTable = new SymbolTable(globalSymbolTable);
		String dataSeg = InterDefines.DSEG_HEAD + "\n\n";
		for (int i = 0; i < ctx.varDeclare().size(); i++) {
			ArrayList<Symbol> varStorage = SyntaxTreeHelper.packVariable(ctx.varDeclare(i), SymbolTable.GLOBAL_VAR, "");
			for (int j = 0; j < varStorage.size(); j++) {
				boolean flag = tmpSymbolTable.insert(varStorage.get(j));
				if (!flag)
					Logger.throwError("Global Variable Redefined: " + varStorage.get(j).name);
			}
		}
		for (int i = 0; i < ctx.arrInit().size(); i++) { // Initialized Array
			dataSeg += visit(ctx.arrInit(i)) + "\n";
		}
		for (String key : globalSymbolTable.keySet()) { // Uninitialized Array
			if (!globalSymbolTable.get(key).initialized)
				dataSeg += InterDefines.DECL_HEAD + " " + globalSymbolTable.get(key).toString() + "\n";
		}
		dataSeg += "\n";
		String codeSeg = InterDefines.CSEG_HEAD + "\n\n";
		for (int i = 0; i < ctx.function().size(); i++) {
			Function newFunc = SyntaxTreeHelper.packFunctionHeader(ctx.function(i));
			boolean flag = functionTable.insert(newFunc);
			if (!flag)
				Logger.throwError("Function Redefined: " + newFunc.name);
		}
		for (int i = 0; i < ctx.function().size(); i++) {
			codeSeg += visit(ctx.function(i)) + "\n";
		}
		return poweredBy + dataSeg + codeSeg;
	}

	@Override
	public String visitArrInit(j8086ccParser.ArrInitContext ctx) {
		String IDN = ctx.IDENTIFIER().getText();
		Symbol curSym = globalSymbolTable.get(IDN);
		if(curSym == null) {
			Logger.throwError("Global variable not defined: " + IDN);
		}
		if(curSym.dataType != Symbol.TYPE_CHAR || !curSym.isArray || curSym.dimension != 1) {
			Logger.throwError("The global variable to be initialized is not char[]: " + IDN);
		}
		String strContent = ctx.STRING().getText();
		curSym.initialized = true;
		return InterDefines.DECL_HEAD + " " + globalSymbolTable.get(IDN).toString() + " " + strContent;
	}

	@Override

	public String visitFunction(j8086ccParser.FunctionContext ctx) {
		String funcName = ctx.IDENTIFIER().getText();
		String funcBegin = InterDefines.FUNC_HEAD + " " + funcName + "\n";
		String funcEnd = InterDefines.FUNC_TAIL + "\n";
		String funcParams = "";
		Function curFunc = functionTable.query(funcName);
		for (int i = 0; i < curFunc.paramList.size(); i++) {
			funcParams += InterDefines.DECL_HEAD + " " + curFunc.paramList.get(i).toString() + "\n";
		}
		SymbolTable curFuncSymbolTable = new SymbolTable(globalSymbolTable);
		for (int i = 0; i < curFunc.paramList.size(); i++) {
			curFuncSymbolTable.insert(curFunc.paramList.get(i));
		}
		symbolTableTree.put(ctx, curFuncSymbolTable);
		return funcBegin + funcParams + visit(ctx.block()) + funcEnd;
	}

	@Override

	public String visitVarDeclare(j8086ccParser.VarDeclareContext ctx) {
		String funcName = SyntaxTreeHelper.getFatherFuncName(ctx);
		ArrayList<Symbol> arrSymbol = SyntaxTreeHelper.packVariable(ctx, SymbolTable.LOCAL_VAR, funcName);
		SymbolTable curFuncSymbolTable = SyntaxTreeHelper.getSymbolTable(symbolTableTree, ctx);
		if (curFuncSymbolTable == null)
			Logger.throwError("Local Variable Defined outside of Function? Unknown Error! ");
		String res = "";
		for (int i = 0; i < arrSymbol.size(); i++) {
			res += InterDefines.DECL_HEAD + " " + arrSymbol.get(i).toString() + "\n";
			curFuncSymbolTable.insert(arrSymbol.get(i));
		}
		return res;
	}

	@Override

	public String visitBlock(j8086ccParser.BlockContext ctx) {
		String res = "";
		if (ctx.statement() == null)
			return res;
		for (int i = 0; i < ctx.statement().size(); i++) {
			res += visit(ctx.statement(i));
		}
		return res;
	}

	@Override

	public String visitSubBlock(j8086ccParser.SubBlockContext ctx) {
		return visit(ctx.block());
	}

	@Override

	public String visitVarDeclStat(j8086ccParser.VarDeclStatContext ctx) {
		return visit(ctx.varDeclare());
	}

	@Override

	public String visitIfSyntax(j8086ccParser.IfSyntaxContext ctx) {
		String condition = visit(ctx.expr());
		Symbol exprResult = exprSymbol.get(ctx.expr());
		int elseLabel = lblCnter.getNewID();
		String jmpLbl = String.format(InterDefines.LABEL, elseLabel) + "\n";
		CtlBeforeLabel.put(ctx, elseLabel);
		String jmpIns = String.format(InterDefines.JZ, exprResult.toString(), elseLabel) + "\n";
		String thenStmt = visit(ctx.statement(0));
		String elseStmt = "";
		if (ctx.statement().size() != 1)
			elseStmt = visit(ctx.statement(1));
		return condition + jmpIns + thenStmt + jmpLbl + elseStmt;
	}

	@Override

	public String visitWhileSyntax(j8086ccParser.WhileSyntaxContext ctx) {
		int startLabel = lblCnter.getNewID(), finishLabel = lblCnter.getNewID();
		CtlBeforeLabel.put(ctx, startLabel);
		CtlAfterLabel.put(ctx, finishLabel);
		String startLbl = String.format(InterDefines.LABEL, startLabel) + "\n";
		String finishLbl = String.format(InterDefines.LABEL, finishLabel) + "\n";
		String condition = visit(ctx.expr());
		Symbol exprResult = exprSymbol.get(ctx.expr());
		String stmt = visit(ctx.statement());
		String jmpOverIns = String.format(InterDefines.JZ, exprResult.toString(), finishLabel) + "\n";
		String jmpStartIns = String.format(InterDefines.JMP, startLabel) + "\n";
		return startLbl + condition + jmpOverIns + stmt + jmpStartIns + finishLbl;
	}

	@Override

	public String visitDoWhileSyntax(j8086ccParser.DoWhileSyntaxContext ctx) {
		int startLabel = lblCnter.getNewID(), finishLabel = lblCnter.getNewID();
		CtlBeforeLabel.put(ctx, startLabel);
		CtlAfterLabel.put(ctx, finishLabel);
		String startLbl = String.format(InterDefines.LABEL, startLabel) + "\n";
		String finishLbl = String.format(InterDefines.LABEL, finishLabel) + "\n";
		String condition = visit(ctx.expr());
		Symbol exprResult = exprSymbol.get(ctx.expr());
		String stmt = visit(ctx.statement());
		String jmpStartIns = String.format(InterDefines.JNZ, exprResult.toString(), startLbl) + "\n";
		return startLbl + stmt + condition + jmpStartIns + finishLbl;
	}

	@Override

	public String visitBreakSyntax(j8086ccParser.BreakSyntaxContext ctx) {
		Integer AfterLbl = SyntaxTreeHelper.getCtlAfterLabel(CtlAfterLabel, ctx);
		if (AfterLbl == null)
			Logger.throwError("Break Syntax Not in Loop!");
		return String.format(InterDefines.JMP, AfterLbl) + "\n";
	}

	@Override

	public String visitContinueSyntax(j8086ccParser.ContinueSyntaxContext ctx) {
		Integer BeforeLbl = SyntaxTreeHelper.getCtlBeforeLabel(CtlBeforeLabel, ctx);
		if (BeforeLbl == null)
			Logger.throwError("Continue Syntax Not in Loop!");
		return String.format(InterDefines.JMP, BeforeLbl) + "\n";
	}

	@Override

	public String visitReturnSyntax(j8086ccParser.ReturnSyntaxContext ctx) {
		String expr = visit(ctx.expr());
		Symbol exprResult = exprSymbol.get(ctx.expr());
		String retStr = String.format(InterDefines.RET, exprResult.toString()) + "\n";
		return expr + retStr;
	}

	@Override

	public String visitLValueAssign(j8086ccParser.LValueAssignContext ctx) {
		String varName = ctx.leftValue().IDENTIFIER().getText();
		SymbolTable curFuncST = SyntaxTreeHelper.getSymbolTable(symbolTableTree, ctx);
		Symbol s = curFuncST.query(varName);
		if (s == null)
			Logger.throwError("Variable Not Exists: " + varName);
		if (!s.isArray) {
			String expr = visit(ctx.expr());
			Symbol exprResult = exprSymbol.get(ctx.expr());
			String movOp = String.format(InterDefines.MOV, s.toString(), exprResult.toString()) + "\n";
			return expr + movOp;
		} else { // isArray
			Symbol arrBaseAddr = SyntaxTreeHelper.genIntLiteralNode(tmpVarCnter);
			String leaIns;
			if (s.isParameter && s.isArray)
				leaIns = String.format(InterDefines.MOV, arrBaseAddr.toString(), s.toString()) + "\n";
			else
				leaIns = String.format(InterDefines.LEA, arrBaseAddr.toString(), s.toString()) + "\n";
			String shiftCalStr = genArrayShiftSize(s, ctx.leftValue());
			Symbol arrShiftAddr = exprSymbol.get(ctx.leftValue());
			String addShiftIns = String.format(InterDefines.ADD, arrBaseAddr.toString(), arrBaseAddr.toString(),
					arrShiftAddr.toString()) + "\n";
			String expr = visit(ctx.expr());
			Symbol exprResult = exprSymbol.get(ctx.expr());
			String movMROp = String.format(InterDefines.MOVMR, arrBaseAddr.toString(), exprResult.toString()) + "\n";
			return leaIns + shiftCalStr + addShiftIns + expr + movMROp;
		}
	}

	@Override

	public String visitExprStat(j8086ccParser.ExprStatContext ctx) {
		if (ctx.expr() != null)
			return visit(ctx.expr());
		else
			return "";
	}

	@Override
	public String visitLogicOrExpr(j8086ccParser.LogicOrExprContext ctx) {
		String str1 = visit(ctx.expr(0));
		String str2 = visit(ctx.expr(1));
		Symbol s1 = exprSymbol.get(ctx.expr(0));
		Symbol s2 = exprSymbol.get(ctx.expr(1));
		Symbol sc = SyntaxTreeHelper.genTmpFatherNode(tmpVarCnter, s1, s2);
		exprSymbol.put(ctx, sc);
		String com = String.format(InterDefines.LOR, sc.toString(), s1.toString(), s2.toString()) + "\n";
		return str1 + str2 + com;
	}

	@Override
	public String visitEqExpr(j8086ccParser.EqExprContext ctx) {
		String str1 = visit(ctx.expr(0));
		String str2 = visit(ctx.expr(1));
		Symbol s1 = exprSymbol.get(ctx.expr(0));
		Symbol s2 = exprSymbol.get(ctx.expr(1));
		Symbol sc = SyntaxTreeHelper.genTmpFatherNode(tmpVarCnter, s1, s2);
		exprSymbol.put(ctx, sc);
		String com;
		if (ctx.op.getType() == j8086ccParser.EQ) {
			com = String.format(InterDefines.EQ, sc.toString(), s1.toString(), s2.toString()) + "\n";
		} else { // NE
			com = String.format(InterDefines.NE, sc.toString(), s1.toString(), s2.toString()) + "\n";
		}
		return str1 + str2 + com;
	}

	@Override
	public String visitUnaryExpr(j8086ccParser.UnaryExprContext ctx) {
		String str = visit(ctx.expr());
		Symbol s = exprSymbol.get(ctx.expr());
		Symbol sc = SyntaxTreeHelper.genTmpFatherNode(tmpVarCnter, s, null);
		exprSymbol.put(ctx, sc);
		String com;
		if (ctx.op.getType() == j8086ccParser.ADD) {
			com = String.format(InterDefines.MOV, sc.toString(), s.toString()) + "\n";
		} else if (ctx.op.getType() == j8086ccParser.SUB) {
			com = String.format(InterDefines.MOVI, sc.toString(), 0) + "\n";
			com += String.format(InterDefines.SUB, sc.toString(), sc.toString(), s.toString()) + "\n";
		} else { // NOT
			com = String.format(InterDefines.LNOT, sc.toString(), s.toString()) + "\n";
		}
		return str + com;
	}

	@Override
	public String visitLogicAndExpr(j8086ccParser.LogicAndExprContext ctx) {
		String str1 = visit(ctx.expr(0));
		String str2 = visit(ctx.expr(1));
		Symbol s1 = exprSymbol.get(ctx.expr(0));
		Symbol s2 = exprSymbol.get(ctx.expr(1));
		Symbol sc = SyntaxTreeHelper.genTmpFatherNode(tmpVarCnter, s1, s2);
		exprSymbol.put(ctx, sc);
		String com = String.format(InterDefines.LAND, sc.toString(), s1.toString(), s2.toString()) + "\n";
		return str1 + str2 + com;
	}

	@Override
	public String visitIntLiteral(j8086ccParser.IntLiteralContext ctx) {
		Symbol s = SyntaxTreeHelper.genIntLiteralNode(tmpVarCnter);
		exprSymbol.put(ctx, s);
		return String.format(InterDefines.MOVI, s.toString(), Integer.valueOf(ctx.getText())) + "\n";
	}

	@Override
	public String visitFunctionCallExpr(j8086ccParser.FunctionCallExprContext ctx) {
		Function curFunc = functionTable.query(ctx.IDENTIFIER().getText());
		if (curFunc == null)
			Logger.throwError("Function not exist: " + ctx.IDENTIFIER().getText());
		if (!(curFunc.paramList.size() == 0 && ctx.exprList() == null
				|| curFunc.paramList.size() == ctx.exprList().expr().size()))
			Logger.throwError("Argument Count invaild: " + curFunc.name);
		String exprCal = "";
		String arguments = "";
		Symbol retS = new Symbol(tmpVarCnter.getNewStringID(), curFunc.retType, SymbolTable.TMP_VAR);
		for (int i = 0; ctx.exprList() != null && i < ctx.exprList().expr().size(); i++) {
			exprCal += visit(ctx.exprList().expr(i));
			arguments += ", " + exprSymbol.get(ctx.exprList().expr(i)).toString();
		}
		String callIns = String.format(InterDefines.CALL, curFunc.name, retS.toString(), arguments) + "\n";
		exprSymbol.put(ctx, retS);
		return exprCal + callIns;
	}

	@Override
	public String visitLValueExpr(j8086ccParser.LValueExprContext ctx) {
		String varName = ctx.leftValue().IDENTIFIER().getText();
		SymbolTable curFuncST = SyntaxTreeHelper.getSymbolTable(symbolTableTree, ctx);
		Symbol s = curFuncST.query(varName);
		if (s == null)
			Logger.throwError("Variable Not Exists: " + varName);
		if (!s.isArray) {
			exprSymbol.put(ctx, s);
			return "";
		} else { // isArray
			Symbol arrBaseAddr = SyntaxTreeHelper.genIntLiteralNode(tmpVarCnter);
			String leaIns;
			if (s.isParameter && s.isArray)
				leaIns = String.format(InterDefines.MOV, arrBaseAddr.toString(), s.toString()) + "\n";
			else
				leaIns = String.format(InterDefines.LEA, arrBaseAddr.toString(), s.toString()) + "\n";
			String shiftCalStr = genArrayShiftSize(s, ctx.leftValue());
			Symbol arrShiftAddr = exprSymbol.get(ctx.leftValue());
			String addShiftIns = String.format(InterDefines.ADD, arrBaseAddr.toString(), arrBaseAddr.toString(),
					arrShiftAddr.toString()) + "\n";
			if (ctx.leftValue().expr().size() != s.dimension) {
				exprSymbol.put(ctx, arrBaseAddr);
				return leaIns + shiftCalStr + addShiftIns;
			}
			Symbol curS = SyntaxTreeHelper.genIntLiteralNode(tmpVarCnter);
			String movRMOp = String.format(InterDefines.MOVRM, curS.toString(), arrBaseAddr.toString()) + "\n";
			exprSymbol.put(ctx, curS);
			return leaIns + shiftCalStr + addShiftIns + movRMOp;
		}
	}

	@Override
	public String visitRelExpr(j8086ccParser.RelExprContext ctx) {
		String str1 = visit(ctx.expr(0));
		String str2 = visit(ctx.expr(1));
		Symbol s1 = exprSymbol.get(ctx.expr(0));
		Symbol s2 = exprSymbol.get(ctx.expr(1));
		Symbol sc = SyntaxTreeHelper.genTmpFatherNode(tmpVarCnter, s1, s2);
		exprSymbol.put(ctx, sc);
		String com;
		if (ctx.op.getType() == j8086ccParser.LT) {
			com = String.format(InterDefines.LT, sc.toString(), s1.toString(), s2.toString()) + "\n";
		} else if (ctx.op.getType() == j8086ccParser.LE) {
			com = String.format(InterDefines.LE, sc.toString(), s1.toString(), s2.toString()) + "\n";
		} else if (ctx.op.getType() == j8086ccParser.GE) {
			com = String.format(InterDefines.GE, sc.toString(), s1.toString(), s2.toString()) + "\n";
		} else { // GT
			com = String.format(InterDefines.GT, sc.toString(), s1.toString(), s2.toString()) + "\n";
		}
		return str1 + str2 + com;
	}

	@Override
	public String visitHighArithExpr(j8086ccParser.HighArithExprContext ctx) {
		String str1 = visit(ctx.expr(0));
		String str2 = visit(ctx.expr(1));
		Symbol s1 = exprSymbol.get(ctx.expr(0));
		Symbol s2 = exprSymbol.get(ctx.expr(1));
		Symbol sc = SyntaxTreeHelper.genTmpFatherNode(tmpVarCnter, s1, s2);
		exprSymbol.put(ctx, sc);
		String com;
		if (ctx.op.getType() == j8086ccParser.MUL) {
			com = String.format(InterDefines.MUL, sc.toString(), s1.toString(), s2.toString()) + "\n";
		} else if (ctx.op.getType() == j8086ccParser.DIV) {
			com = String.format(InterDefines.DIV, sc.toString(), s1.toString(), s2.toString()) + "\n";
		} else { // MOD
			com = String.format(InterDefines.MOD, sc.toString(), s1.toString(), s2.toString()) + "\n";
		}
		return str1 + str2 + com;
	}

	@Override
	public String visitLowArithExpr(j8086ccParser.LowArithExprContext ctx) {
		String str1 = visit(ctx.expr(0));
		String str2 = visit(ctx.expr(1));
		Symbol s1 = exprSymbol.get(ctx.expr(0));
		Symbol s2 = exprSymbol.get(ctx.expr(1));
		Symbol sc = SyntaxTreeHelper.genTmpFatherNode(tmpVarCnter, s1, s2);
		exprSymbol.put(ctx, sc);
		String com;
		if (ctx.op.getType() == j8086ccParser.ADD) {
			com = String.format(InterDefines.ADD, sc.toString(), s1.toString(), s2.toString()) + "\n";
		} else { // SUB
			com = String.format(InterDefines.SUB, sc.toString(), s1.toString(), s2.toString()) + "\n";
		}
		return str1 + str2 + com;
	}

	@Override
	public String visitParenExpr(j8086ccParser.ParenExprContext ctx) {
		String res = visit(ctx.expr());
		exprSymbol.put(ctx, exprSymbol.get(ctx.expr()));
		return res;
	}
}
